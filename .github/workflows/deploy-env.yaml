name: Deploy - Environment

on:
  push:
    branches:
      - main
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: "Environment to deploy to"
        required: true
        default: "Test"
        options:
          - "Test"
          - "Staging"
          - "Production"
          - "elz-test"
      clear-cache:
        type: choice
        description: "Clear the cache?"
        required: true
        default: "False"
        options:
          - "True"
          - "False"
      # service-id is only needed while testing migration and should be removed
      service-id:
        type: choice
        description: "Service ID?"
        required: true
        default: "s272"
        options:
          - "s186"
          - "s272"
      # release-type is only needed while testing migration and should be removed
      release-type:
        type: choice
        description: "Type of release"
        required: true
        default: "infraplan"
        options:
          - "full"
          - "infraplan"

run-name: ${{ github.event_name == 'push' && 'Build & Deploy to Test' || format('Deploy to {0}', github.event_name == 'release' && 'Production' || github.event.inputs.environment) }}

jobs:
  validate_web:
    #if: github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    #'if' only needed for migration testing
    if: github.event.inputs.release-type == 'full'
    name: Validate Web
    uses: ./.github/workflows/validate-web.yaml

  tag_release:
    #'if' only needed for migration testing
    if: github.event.inputs.release-type == 'full'
    name: Create New Tag
    runs-on: ubuntu-latest
    needs: [validate_web]
    outputs:
      new_tag: ${{ steps.tag_version.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        if: github.event_name == 'push'
        with:
          fetch-depth: 0
      - name: Bump version and push tag
        id: tag_version
        if: github.event_name == 'push'
        uses: mathieudutour/github-tag-action@v6.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          release_branches: main

  package:
    name: "Package Web in Docker"
    runs-on: ubuntu-latest
    needs: [validate_web, tag_release]
    #'if' only needed for migration testing
    if: github.event.inputs.release-type == 'full'
    # if: always() &&
    #   (github.event_name == 'push' && needs.tag_release.result == 'success') ||
    #   (github.event_name == 'release' && needs.validate_web.result == 'success') ||
    #   (github.event_name == 'workflow_dispatch' && needs.validate_web.result == 'success')

    defaults:
      run:
        working-directory: ./src
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.set_tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Lowercase the repo name and username
        run: echo "REPO=${GITHUB_REPOSITORY,,}" >>${GITHUB_ENV}

      # Set docker image tag based on event type - release tag, new tag from push, or commit SHA for manual run
      - name: Set Docker image tag
        id: set_tag
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "Using release tag for versioning: ${{ github.ref_name }}"
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "Using new auto-generated tag for versioning: ${{ needs.tag_release.outputs.new_tag }}"
            echo "tag=${{ needs.tag_release.outputs.new_tag }}" >> $GITHUB_OUTPUT
          else
            echo "Using commit SHA for versioning for manual run"
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Build Web Docker Image
        run: |
          docker build . -t ghcr.io/${{ env.REPO }}:${{ steps.set_tag.outputs.tag }} -f web/CareLeavers.Web/Dockerfile

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Web Docker Image
        run: docker push ghcr.io/${{ env.REPO }}:${{ steps.set_tag.outputs.tag }}

  deploy_environment:
    name: Deploying site to ${{ (github.event_name == 'release' && 'Production') || (github.event_name == 'push' && 'Test') || github.event.inputs.environment }}
    runs-on: ubuntu-latest
    #needs: [package]
    #if: github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      id-token: write
    environment:
      name: ${{ (github.event_name == 'release' && 'Production') || (github.event_name == 'push' && 'Test') || github.event.inputs.environment }}
    env:
      ARM_CLIENT_ID: "${{ secrets.AZURE_CLIENT_ID }}"
      ARM_SUBSCRIPTION_ID: "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
      ARM_TENANT_ID: "${{ secrets.AZURE_TENANT_ID }}"
      ARM_CLIENT_SECRET: "${{ secrets.AZURE_CLIENT_SECRET }}"

    steps:
      #Set dynamic variables based on deployment type - push to main, release or manual run
      - name: Set dynamic variables
        id: vars
        run: |
          ENV_NAME="${{ (github.event_name == 'release' && 'Production') || (github.event_name == 'push' && 'Test') || github.event.inputs.environment }}"
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_ENV
          echo "Deployment Environment: $ENV_NAME"

          if [[ "${{ github.event_name }}" == "release" ]]; then
            BODY="${{ github.event.release.body }}"
            CACHE_VALUE=$(echo "$BODY" | grep 'clear-cache:' | awk -F': ' '{print $2}' | tr -d '[:space:]')
            echo "clear_cache=${CACHE_VALUE:-False}" >> $GITHUB_OUTPUT
            echo "Clear Cache: ${CACHE_VALUE:-False}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "clear_cache=False" >> $GITHUB_OUTPUT
            echo "Clear Cache: False"
          else
            echo "clear_cache=${{ github.event.inputs.clear-cache }}" >> $GITHUB_OUTPUT
            echo "Clear Cache: ${{ github.event.inputs.clear-cache }}"
          fi

      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
          terraform_version: 1.10.4

      - name: "Az CLI login"
        uses: azure/login@v2
        with:
          creds: |
            {
                "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
                "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
                "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
                "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }

      - name: Create TF State dependencies
        uses: azure/cli@v2
        env:
          ENVIRONMENT_PREFIX: "${{github.event.inputs.service-id}}${{ vars.ENVIRONMENT_PREFIX }}"
          CIP_ENVIRONMENT: ${{ vars.CIP_ENVIRONMENT }}
        with:
          azcliversion: latest
          inlineScript: |
            az group create --name ${ENVIRONMENT_PREFIX}rg-uks-cl-tfstate --location uksouth --output none --tags "Environment=${CIP_ENVIRONMENT}" "Product=Design Operations" "Service=Newly onboarded" "Service offering=Design operations"
            az storage account create --name ${ENVIRONMENT_PREFIX}cltfstate --resource-group ${ENVIRONMENT_PREFIX}rg-uks-cl-tfstate --location uksouth --sku Standard_LRS --min-tls-version TLS1_2 --https-only true
            az storage container create --name tfstate --account-name ${ENVIRONMENT_PREFIX}cltfstate

      - name: "Terraform Init"
        id: terraform_init
        working-directory: ./src/infrastructure/terraform
        env:
          ENVIRONMENT_PREFIX: "${{github.event.inputs.service-id}}${{ vars.ENVIRONMENT_PREFIX }}"
        run: terraform init -backend-config="resource_group_name=${ENVIRONMENT_PREFIX}rg-uks-cl-tfstate" -backend-config="storage_account_name=${ENVIRONMENT_PREFIX}cltfstate" -backend-config="container_name=tfstate" -backend-config="key=terraform.tfstate"

      - name: "Terraform Plan"
        id: terraform_plan
        working-directory: ./src/infrastructure/terraform
        run: terraform plan -out plan.plan
        env:
          TF_VAR_aspnetcore_environment: ${{ env.ENV_NAME }}
          TF_VAR_environment_prefix: ${{ vars.ENVIRONMENT_PREFIX }}
          TF_VAR_elz_environment: ${{ vars.CIP_ENVIRONMENT }}
          TF_VAR_contentful_delivery_api_key: ${{ secrets.CONTENTFUL_DELIVERY_API_KEY }}
          TF_VAR_contentful_preview_api_key: ${{ secrets.CONTENTFUL_PREVIEW_API_KEY }}
          TF_VAR_contentful_management_api_key: ${{ secrets.CONTENTFUL_MANAGEMENT_TOKEN }}
          TF_VAR_contentful_space_id: ${{ secrets.CONTENTFUL_SPACE_ID }}
          TF_VAR_contentful_environment: ${{ vars.CONTENTFUL_ENVIRONMENT }}
          TF_VAR_contentful_use_preview_api: ${{ vars.CONTENTFUL_PREVIEW }}
          TF_VAR_caching_type: ${{ vars.CACHING_TYPE }}
          TF_VAR_scripts_clarity: ${{ vars.SCRIPTS_CLARITY }}
          TF_VAR_custom_domain: ${{ vars.CUSTOM_DOMAIN }}
          TF_VAR_azure_translation_document_endpoint: ${{ vars.AZURE_TRANSLATION_DOCUMENT_ENDPOINT }}
          TF_VAR_azure_translation_access_key: ${{ secrets.AZURE_TRANSLATION_ACCESS_KEY }}
          TF_VAR_azure_frontdoor_scale: ${{ vars.AZURE_FRONTDOOR_SCALE }}
          TF_VAR_pdf_generation_api_key: ${{ secrets.PDF_GENERATION_API_KEY }}
          TF_VAR_pdf_generation_use_sandbox: ${{ vars.PDF_GENERATION_USE_SANDBOX }}
          TF_VAR_rebrand: ${{ vars.REBRAND }}
          TF_VAR_support_alert_email: ${{ secrets.SUPPORT_ALERT_EMAIL }}
          TF_VAR_gtaa_base_url: ${{ vars.GTAA_BASE_URL }}

      - name: "Terraform Apply"
        #'if' only needed for migration testing
        if: github.event.inputs.release-type == 'full'
        id: terraform_apply
        working-directory: ./src/infrastructure/terraform
        run: terraform apply plan.plan

      - name: Lowercase the repo name and username
        run: echo "REPO=${GITHUB_REPOSITORY,,}" >>${GITHUB_ENV}

      - name: Deploy to Azure Web App
        #'if' only needed for migration testing
        if: github.event.inputs.release-type == 'full'
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v3
        env:
          ENVIRONMENT_PREFIX: "${{github.event.inputs.service-id}}${{vars.ENVIRONMENT_PREFIX}}"
        with:
          app-name: "${{env.ENVIRONMENT_PREFIX}}-cl-web-app-service"
          slot-name: "staging"
          images: "ghcr.io/${{ env.REPO }}:${{ needs.package.outputs.image_tag }}"

      - name: Swap slot to production
        #'if' only needed for migration testing
        if: github.event.inputs.release-type == 'full'
        env:
          ENVIRONMENT_PREFIX: "${{github.event.inputs.service-id}}${{vars.ENVIRONMENT_PREFIX}}"
        run: az webapp deployment slot swap --name ${{ env.ENVIRONMENT_PREFIX }}-cl-web-app-service --resource-group ${{ env.ENVIRONMENT_PREFIX }}rg-weu-cl-web-rg --slot staging --target-slot production

      - name: Delete staging slot
        #'if' only needed for migration testing
        if: github.event.inputs.release-type == 'full'
        env:
          ENVIRONMENT_PREFIX: "${{github.event.inputs.service-id}}${{vars.ENVIRONMENT_PREFIX}}"
        run: az webapp deployment slot delete --name ${{ env.ENVIRONMENT_PREFIX }}-cl-web-app-service --resource-group ${{ env.ENVIRONMENT_PREFIX }}rg-weu-cl-web-rg --slot staging

      - name: Clear Cache
        id: clear-cache
        uses: fjogeleit/http-request-action@v1
        if: ${{ steps.vars.outputs.clear_cache == 'True' }}
        with:
          url: "https://${{ vars.CUSTOM_DOMAIN }}/b0e0dce2-b96d-4b94-a800-63c3ab56e72f"
          method: "POST"
